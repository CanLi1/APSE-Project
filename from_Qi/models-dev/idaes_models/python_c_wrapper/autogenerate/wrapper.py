from os import listdir
from os.path import isfile
import os
import inspect

# Used in filtering the Python module directory:
INIT = "__init__.py"
PY = ".py"
DECORATOR = "@wrapthis"

# Used in parsing the module name and automatic code generation:
FUNCGEN = 'FUNCGEN({0},{1});\n'
ADDFUNC = 'addfunc(\"{0}\", (rfunc){1},t,{2},NULL);\n'
NARGS=-2

# Used to generate the properties method C library file:
LIB_NAME = "phys_prop_C_auto"
EXTENSION = "c"
OBJECT_FILE = "o"
SO_FILE = "so"

STUB_CODE = """
	/* THIS CODE IS AUTOGENERATED */
	#include <Python.h>
	#include "solvers/funcadd.h"
	#include "wrapper.h"

	{0}

	void funcadd(AmplExports *ae)
	{{
	    int t = 0;
	    {1}
	}}
	"""

# Used in compiling the wrapper library: 
WRAPPER_CONFIGURE_COMMAND = "./configure CPPFLAGS=\"{0}\" --with-adolc={1}"
WRAPPER_SRC_DIR = "idaes_models/python_c_wrapper/wrapper"
MAKE = "make"

#Used in compiling properties library:
WRAPPER_LIB_DIR = "idaes_models/python_c_wrapper/wrapper/.libs"
AUTOCONF="autoconf"

#Used to generate helper script to set environment variables:
HELPER_SCRIPT = """#!/bin/bash
export PYTHONPATH=$PYTHONPATH:{0}
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:{1}:{2}/{3}:{4}\n"""
HELPER_NAME = "python_c_wrapper_helper.sh"
PYTHON = "python"

def get_method_list(directory):

	import sys
	sys.path.insert(0,directory)
	funcgen_statements = []
	addfunc_statements = []

	if not directory.endswith("/"):
		directory += "/"
	modules = [f for f in listdir(directory) if isfile(directory+f) and f.endswith(".py")]
	for module in modules:
		# Skip __init__.py:
		if module == INIT:
			pass
		else:
			module = module[0:module.find(PY)]
			try:
				module_obj = __import__(module)
			except ImportError:
				print("Module not found, modify your PYTHONPATH environment variable to include {0}?".format(directory))
				import traceback
				print("Encountered exception. Details:")
				print(traceback.format_exc())
				return funcgen_statements,addfunc_statements
			try:
				decorated_functions = []
				member_list = inspect.getmembers(module_obj)
				sourcelines = inspect.getsourcelines(module_obj)[0]
				for i,line in enumerate(sourcelines):
					line = line.strip()
					if DECORATOR in line:
						line_after_decorator = sourcelines[i+1]
						method_to_wrap = line_after_decorator.split('def')[1].split('(')[0].strip()
						decorated_functions.append(method_to_wrap)

				# Get list of all functions in a module:
				functions_list = inspect.getmembers(module_obj,inspect.isfunction)
				
				if (len(functions_list) == 0):
					print ("[{0}/{1}.py] does not define any compatible functions.".format(directory,module))
				else:
				    for function in functions_list:
				    	function_name = function[0]
				    	# Filter only on functions defined in the module and that are decorated:
				    	function_module_name = function[1].__globals__["__name__"]
				    	if (function_name in decorated_functions):
				    		funcgen_statements.append(FUNCGEN.format(module,function_name))
				    		addfunc_statements.append(ADDFUNC.format(function_name,function_name,NARGS))
			except:
				import traceback
				print("Encountered exception. Details:")
				print(traceback.format_exc())
	return (funcgen_statements,addfunc_statements)

def make_clean(MODELS_HOME):
	command = ['make','clean']
	program = None
	try:
		import subprocess
		os.chdir("{0}/{1}".format(MODELS_HOME,WRAPPER_SRC_DIR))
		program = subprocess.Popen(command,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
		print ("Cleaning up wrapper library...\n {0} \n".format(program.communicate()[0]))
		return True
	except:
		print("Encountered error when cleaning up the wrapper library directory.")
		import traceback
		print("Encountered exception. Details:")
		print(traceback.format_exc())
		return False

def compile_wrapper_library(CPPFLAGS,MODELS_HOME,ADOLC_LIBS):
	# Configure step:
	program = None
	try:
		import subprocess
		# Attempt to do a make clean:
		if not make_clean(MODELS_HOME):
			return False
		
		os.chdir("{0}/{1}".format(MODELS_HOME,WRAPPER_SRC_DIR))
		program = subprocess.Popen([AUTOCONF],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
		program = subprocess.Popen(["automake"],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
		if 'NERSC_HOST' in os.environ:
			# If on a NERSC host, add proper Python paths to configure:
			command = ["./configure","CPPFLAGS=-I/usr/common/software/python/2.7.9/include/python2.7 {0}".format(CPPFLAGS),\
			"--with-adolc={0}".format(ADOLC_LIBS),"--with-python=/usr/common/software/python/2.7.9/lib"]
		else:
			command = ["./configure","CPPFLAGS={0}".format(CPPFLAGS),"--with-adolc={0}".format(ADOLC_LIBS), \
			"--with-python=/not/a/path"]
		program = subprocess.Popen(command,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
	except:
		import traceback
		print("Encountered exception. Details:")
		print(traceback.format_exc())

		print("Encountered error when configuring the wrapper library. Full error output:")
		if program is not None:
			print(program.communicate()[0])
		return False

	# Compile step:
	try:
		import subprocess
		os.chdir("{0}/{1}".format(MODELS_HOME,WRAPPER_SRC_DIR))
		program = subprocess.Popen(MAKE,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
		print ("Compiling wrapper library...\n {0} \n".format(program.communicate()[0]))
		return True
	except:
		print ("Encountered exception when compiling the wrapper library. Full error output:")
		print ("Wrapper compilation\n{0}\n".format(program.communicate()[1]))
		return False

def generate_c_code (dest, funcgen_statements,addfunc_statements):

	funcgen = ''.join(funcgen_statements)
	addfunc = ''.join(addfunc_statements)

	try:
		full_file = "{0}/{1}.{2}".format(dest,LIB_NAME,EXTENSION)
		f = open(full_file,'w')
		f.write(STUB_CODE.format(funcgen,addfunc))
		f.close()
		return True
	except:
		print("Could not write C file in destination {0}".format(dest))
		return False

def wrap(dest,CPPFLAGS,MODELS_HOME,ADOLC_LIBS):
	"""g++ -c -Wall -Wextra -O3 -fPIC -std=c++11 
	-I/usr/local/src/Ipopt-3.12.5/ThirdParty/ASL -I/opt/conda/pkgs/python-2.7.12-0/include/python2.7 
	-I/home/jovyan/models/models-fork/models/src/wrapper 
	phys_prop_minimal.c -o phys_prop_minimal.o"""

	try:
		import subprocess
		os.chdir(dest)
		include_paths = CPPFLAGS.split()
		command = ['g++','-c','-Wall','-Wextra','-O3','-fPIC','-std=c++11']
		command += include_paths
		command += ['-I{0}/{1}'.format(MODELS_HOME,WRAPPER_SRC_DIR), '{0}.{1}'.format(LIB_NAME,EXTENSION), \
		'-o','{0}.{1}'.format(LIB_NAME,OBJECT_FILE)]

		program = subprocess.Popen(command,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
		print ("Compiler output :\n {0} \n".format(program.communicate()[1]))
	except:
		print ("Failed to compile properties library [1st step, generating .o]")

	"""g++ -L/usr/local/lib64 -ladolc -L/home/jovyan/models/models-fork/models/src/wrapper/.libs 
	-lwrapper -shared -lm -lpython2.7 phys_prop_minimal.o -o phys_prop_minimal.so
	"""
	
	try:
		import subprocess
		os.chdir(dest)
		if 'NERSC_HOST' in os.environ:
			# If on a NERSC host, point linker to Python:
			command = ['g++','-L{0}'.format(ADOLC_LIBS),'-ladolc','-L{0}/{1}'.format(MODELS_HOME,WRAPPER_LIB_DIR), \
			'-lwrapper','-shared','-lm', '-L/usr/common/software/python/2.7.9/lib','-lpython2.7', '{0}.{1}'.format(LIB_NAME,OBJECT_FILE), '-o','{0}.{1}'.format(LIB_NAME,SO_FILE)]
		else:
			command = ['g++','-L{0}'.format(ADOLC_LIBS),'-ladolc','-L{0}/{1}'.format(MODELS_HOME,WRAPPER_LIB_DIR), \
			'-lwrapper','-shared','-lm', '-lpython2.7', '{0}.{1}'.format(LIB_NAME,OBJECT_FILE), '-o','{0}.{1}'.format(LIB_NAME,SO_FILE)]			
		program = subprocess.Popen(command,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
		return True
	except:
		import traceback
		print("Encountered exception. Details:")
		print(traceback.format_exc())
		print ("Failed to compile properties library [2nd step, generating .so]")
		return False

def generate_export_statements(dest,path,MODELS_HOME,ADOLC_LIBS,CPPFLAGS):
	try:
		# Extract Python path from CPPFLAGS:
		python_path = ""
		include_paths = CPPFLAGS.split()
		for include in include_paths:
			if PYTHON in include:
				python_path = include[include.find("I"):] 
		
		full_file = "{0}/{1}".format(dest,HELPER_NAME)
		f = open(full_file,'w')
		f.write(HELPER_SCRIPT.format(path,ADOLC_LIBS,MODELS_HOME,WRAPPER_LIB_DIR,python_path))
		f.close()
		return True
	except:
		print("Could not write helper script file in destination {0}".format(dest))
		return False
